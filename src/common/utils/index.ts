/// helpersç±»
import { Call } from '../../solidity/trace/traceCache';
import { findLowerBound, findLowerBoundValue } from './sort';
import stringSimilarity from 'string-similarity';

import { BN, bufferToHex, keccak, setLengthLeft, toBuffer, addHexPrefix } from 'ethereumjs-util';

/**
  * Find the call from @args rootCall which contains @args index (recursive)
  *
  * @param {Int} index - index of the vmtrace
  * @param {Object} rootCall  - call tree, built by the trace analyser
  * @return {Object} - return the call which include the @args index
  */
function findCall(index: number, rootCall: Call) {
    const ret = buildCallPath(index, rootCall);
    return ret[ret.length - 1];
}

/**
* Find calls path from @args rootCall which leads to @args index (recursive)
*
* @param {Int} index - index of the vmtrace
* @param {Object} rootCall  - call tree, built by the trace analyser
* @return {Array} - return the calls path to @args index
*/
function buildCallPath(index: number, rootCall: Call) {
    const ret: Call[] = [];
    findCallInternal(index, rootCall, ret);
    return ret;
}

/**
  * sha3 the given @arg value (left pad to 32 bytes)
  *
  * @param {String} value - value to sha3
  * @return {Object} - return sha3ied value
  */
// eslint-disable-next-line camelcase
function sha3_256(value: string) {
    const buffer = toBuffer(addHexPrefix(value));
    const retInBuffer: Buffer = keccak(setLengthLeft(buffer, 32));
    return bufferToHex(retInBuffer);
}


function findCallInternal(index: number, rootCall: Call, callsPath: Call[]) {
    const calls = Object.keys(rootCall.calls).map(Number);
    const ret = rootCall;
    callsPath.push(rootCall);
    for (const k in calls) {
        const subCall = rootCall.calls[calls[k]];
        if (index >= subCall.start && index <= subCall.return!) {
            findCallInternal(index, subCall, callsPath);
            break;
        }
    }
    return ret;
}


/**
  * Compare bytecode. return true if the code is equal (handle swarm hash and library references)
  * @param {String} code1 - the bytecode that is actually deployed (contains resolved library reference and a potentially different swarmhash)
  * @param {String} code2 - the bytecode generated by the compiler (contains unresolved library reference and a potentially different swarmhash)
                            this will return false if the generated bytecode is empty (asbtract contract cannot be deployed)
  *
  * @return {bool}
  */
function compareByteCode(code1: string, code2: string) {
    if (code1 === code2) {
        return true;
    }
    if (code2 === '0x') {
        return false; // abstract contract. see comment
    }

    if (code2.substr(2, 46) === '7300000000000000000000000000000000000000003014') {
        // testing the following signature: PUSH20 00..00 ADDRESS EQ
        // in the context of a library, that slot contains the address of the library (pushed by the compiler to avoid calling library other than with a DELEGATECALL)
        // if code2 is not a library, well we still suppose that the comparison remain relevant even if we remove some information from `code1`
        code1 = replaceLibReference(code1, 4);
    }
    let pos = -1;
    while ((pos = code2.search(/__(.*)__/)) !== -1) {
        code2 = replaceLibReference(code2, pos);
        code1 = replaceLibReference(code1, pos);
    }
    code1 = extractSwarmHash(code1);
    code1 = extractcborMetadata(code1);
    code2 = extractSwarmHash(code2);
    code2 = extractcborMetadata(code2);

    if (code1 && code2) {
        const compare = stringSimilarity.compareTwoStrings(code1, code2);
        return compare > 0.93;
    }

    return false;
}

function extractcborMetadata(value: string) {
    return value.replace(cborEncodedValueExtraction(), '');
}

function cborEncodedValueExtraction() {
    return /64697066735822([0-9a-f]{68})64736f6c6343([0-9a-f]{6})0033$/;
}

function extractSwarmHash(value: string) {
    value = value.replace(swarmHashExtraction(), '');
    value = value.replace(swarmHashExtractionPOC31(), '');
    value = value.replace(swarmHashExtractionPOC32(), '');
    return value;
}
/**
  * return a regex which extract the swarmhash from the bytecode.
  *
  * @return {RegEx}
  */
function swarmHashExtraction() {
    return /a165627a7a72305820([0-9a-f]{64})0029$/;
}

/**
  * return a regex which extract the swarmhash from the bytecode, from POC 0.3
  *
  * @return {RegEx}
  */
function swarmHashExtractionPOC31() {
    return /a265627a7a72315820([0-9a-f]{64})64736f6c6343([0-9a-f]{6})0032$/;
}

/**
  * return a regex which extract the swarmhash from the bytecode, from POC 0.3
  *
  * @return {RegEx}
  */
function swarmHashExtractionPOC32() {
    return /a265627a7a72305820([0-9a-f]{64})64736f6c6343([0-9a-f]{6})0032$/;
}

function replaceLibReference(code: string, pos: number) {
    return code.substring(0, pos) + '0000000000000000000000000000000000000000' + code.substring(pos + 40);
}


function normalizeHexAddress(hex: string) {
    if (hex.indexOf('0x') === 0) {
        hex = hex.replace('0x', '');
    }
    if (hex.length >= 40) {
        const reg = /(.{40})$/.exec(hex);
        if (reg) {
            return '0x' + reg[0];
        }
    } else {
        return '0x' + (new Array(40 - hex.length + 1).join('0')) + hex;
    }
}

export const util = {
    findLowerBound,
    sha3_256,
    buildCallPath,
    findCall,
    compareByteCode,
    normalizeHexAddress,
    findLowerBoundValue,
};